<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Web - Voxel World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #87CEEB;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            cursor: none;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .slot {
            width: 50px;
            height: 50px;
            border: 2px solid #333;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .slot.selected {
            border-color: #fff;
            background: rgba(255,255,255,0.2);
        }

        .slot img {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            transform: translateY(-50%);
        }

        #crosshair::after {
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            transform: translateX(-50%);
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
        }

        #instructions.hidden {
            display: none;
        }

        .controls {
            margin: 10px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div>FPS: <span id="fps">60</span></div>
        <div>Blocks: <span id="blockCount">0</span></div>
        <div>Position: <span id="position">0, 0, 0</span></div>
    </div>

    <div id="crosshair"></div>

    <div id="inventory">
        <div class="slot selected" data-block="grass">ðŸŸ©</div>
        <div class="slot" data-block="dirt">ðŸŸ«</div>
        <div class="slot" data-block="stone">â¬œ</div>
        <div class="slot" data-block="wood">ðŸŸ¨</div>
        <div class="slot" data-block="leaves">ðŸŸ¢</div>
    </div>

    <div id="instructions">
        <h2>Minecraft Web</h2>
        <div class="controls">
            <p><strong>WASD</strong> - Move around</p>
            <p><strong>Mouse</strong> - Look around</p>
            <p><strong>Left Click</strong> - Break blocks</p>
            <p><strong>Right Click</strong> - Place blocks</p>
            <p><strong>1-5</strong> - Select blocks</p>
            <p><strong>Space</strong> - Jump/Fly up</p>
            <p><strong>Shift</strong> - Fly down</p>
        </div>
        <p><button onclick="startGame()">Click to Start</button></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class MinecraftGame {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
                
                this.world = new Map();
                this.blockTypes = {
                    grass: { color: 0x7CB342, top: 0x8BC34A, side: 0x689F38 },
                    dirt: { color: 0x8D6E63 },
                    stone: { color: 0x9E9E9E },
                    wood: { color: 0x8D6E63, top: 0xA1887F },
                    leaves: { color: 0x4CAF50 }
                };
                
                this.selectedBlock = 'grass';
                this.keys = {};
                this.mouse = { x: 0, y: 0 };
                this.velocity = new THREE.Vector3();
                this.canJump = false;
                
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                
                this.init();
            }

            init() {
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Setup camera
                this.camera.position.set(0, 50, 0);

                // Setup lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                this.scene.add(directionalLight);

                // Generate initial world
                this.generateWorld();

                // Setup controls
                this.setupControls();

                // Start game loop
                this.animate();
            }

            generateWorld() {
                const size = 32;
                const height = 10;
                
                for (let x = -size; x < size; x++) {
                    for (let z = -size; z < size; z++) {
                        const noise = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 5;
                        const groundHeight = Math.floor(height + noise);
                        
                        // Generate terrain layers
                        for (let y = 0; y < groundHeight; y++) {
                            let blockType = 'stone';
                            if (y === groundHeight - 1) blockType = 'grass';
                            else if (y > groundHeight - 4) blockType = 'dirt';
                            
                            this.placeBlock(x, y, z, blockType);
                        }
                        
                        // Add some trees
                        if (Math.random() < 0.02 && groundHeight > height) {
                            this.generateTree(x, groundHeight, z);
                        }
                    }
                }
            }

            generateTree(x, y, z) {
                // Tree trunk
                for (let i = 0; i < 4; i++) {
                    this.placeBlock(x, y + i, z, 'wood');
                }
                
                // Tree leaves
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        for (let dy = 0; dy < 3; dy++) {
                            if (Math.abs(dx) + Math.abs(dz) + dy < 4) {
                                this.placeBlock(x + dx, y + 3 + dy, z + dz, 'leaves');
                            }
                        }
                    }
                }
            }

            placeBlock(x, y, z, type) {
                const key = `${x},${y},${z}`;
                if (this.world.has(key)) return;

                const blockData = this.blockTypes[type];
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                
                let material;
                if (blockData.top) {
                    const materials = [
                        new THREE.MeshLambertMaterial({ color: blockData.side || blockData.color }), // right
                        new THREE.MeshLambertMaterial({ color: blockData.side || blockData.color }), // left
                        new THREE.MeshLambertMaterial({ color: blockData.top }), // top
                        new THREE.MeshLambertMaterial({ color: blockData.color }), // bottom
                        new THREE.MeshLambertMaterial({ color: blockData.side || blockData.color }), // front
                        new THREE.MeshLambertMaterial({ color: blockData.side || blockData.color })  // back
                    ];
                    material = materials;
                } else {
                    material = new THREE.MeshLambertMaterial({ color: blockData.color });
                }

                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(x, y, z);
                cube.castShadow = true;
                cube.receiveShadow = true;
                
                this.scene.add(cube);
                this.world.set(key, { mesh: cube, type: type });
            }

            removeBlock(x, y, z) {
                const key = `${x},${y},${z}`;
                const block = this.world.get(key);
                if (block) {
                    this.scene.remove(block.mesh);
                    block.mesh.geometry.dispose();
                    if (Array.isArray(block.mesh.material)) {
                        block.mesh.material.forEach(mat => mat.dispose());
                    } else {
                        block.mesh.material.dispose();
                    }
                    this.world.delete(key);
                }
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    // Block selection
                    if (e.code >= 'Digit1' && e.code <= 'Digit5') {
                        const blocks = ['grass', 'dirt', 'stone', 'wood', 'leaves'];
                        const index = parseInt(e.code.slice(-1)) - 1;
                        this.selectedBlock = blocks[index];
                        this.updateInventoryUI();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === this.renderer.domElement) {
                        this.mouse.x += e.movementX * 0.002;
                        this.mouse.y += e.movementY * 0.002;
                        this.mouse.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.mouse.y));
                    }
                });

                document.addEventListener('click', (e) => {
                    if (document.pointerLockElement !== this.renderer.domElement) return;
                    
                    this.mouseVector.x = 0;
                    this.mouseVector.y = 0;
                    this.raycaster.setFromCamera(this.mouseVector, this.camera);

                    const objects = Array.from(this.world.values()).map(block => block.mesh);
                    const intersects = this.raycaster.intersectObjects(objects);

                    if (intersects.length > 0) {
                        const intersect = intersects[0];
                        const point = intersect.point;
                        const normal = intersect.face.normal;
                        
                        if (e.button === 0) { // Left click - remove block
                            const pos = intersect.object.position;
                            this.removeBlock(pos.x, pos.y, pos.z);
                        } else { // Right click - place block
                            const newPos = point.clone().add(normal).floor();
                            this.placeBlock(newPos.x, newPos.y, newPos.z, this.selectedBlock);
                        }
                    }
                });

                document.addEventListener('contextmenu', (e) => e.preventDefault());

                // Inventory clicks
                document.querySelectorAll('.slot').forEach(slot => {
                    slot.addEventListener('click', () => {
                        this.selectedBlock = slot.dataset.block;
                        this.updateInventoryUI();
                    });
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            updateInventoryUI() {
                document.querySelectorAll('.slot').forEach(slot => {
                    slot.classList.toggle('selected', slot.dataset.block === this.selectedBlock);
                });
            }

            updatePlayer() {
                const speed = 0.2;
                const direction = new THREE.Vector3();

                if (this.keys['KeyW']) direction.z -= 1;
                if (this.keys['KeyS']) direction.z += 1;
                if (this.keys['KeyA']) direction.x -= 1;
                if (this.keys['KeyD']) direction.x += 1;

                direction.normalize().multiplyScalar(speed);
                direction.applyEuler(new THREE.Euler(0, this.mouse.x, 0));

                this.camera.position.add(direction);

                if (this.keys['Space']) this.camera.position.y += speed;
                if (this.keys['ShiftLeft']) this.camera.position.y -= speed;

                // Update camera rotation
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.mouse.x;
                this.camera.rotation.x = this.mouse.y;

                // Update UI
                const pos = this.camera.position;
                document.getElementById('position').textContent = 
                    `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
                document.getElementById('blockCount').textContent = this.world.size;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.updatePlayer();
                this.renderer.render(this.scene, this.camera);

                // Update FPS
                const fps = Math.round(1000 / 16.67); // Approximate
                document.getElementById('fps').textContent = fps;
            }
        }

        let game;

        function startGame() {
            const instructions = document.getElementById('instructions');
            instructions.classList.add('hidden');
            
            const canvas = document.getElementById('gameCanvas');
            canvas.requestPointerLock();
            
            game = new MinecraftGame();
        }

        // Auto-start when pointer is locked
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement) {
                document.getElementById('instructions').classList.add('hidden');
                if (!game) {
                    game = new MinecraftGame();
                }
            }
        });
    </script>
</body>
</html>